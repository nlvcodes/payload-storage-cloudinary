"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/kareem@2.6.3";
exports.ids = ["vendor-chunks/kareem@2.6.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/kareem@2.6.3/node_modules/kareem/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/kareem@2.6.3/node_modules/kareem/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\n\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Optional arguments or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPre = function(name, context, args, callback) {\n  if (arguments.length === 3) {\n    callback = args;\n    args = [];\n  }\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  const numAsyncPres = pres.numAsync || 0;\n  let currentPre = 0;\n  let asyncPresLeft = numAsyncPres;\n  let done = false;\n  const $args = args;\n  let shouldSkipWrappedFunction = null;\n\n  if (!numPres) {\n    return nextTick(function() {\n      callback(null);\n    });\n  }\n\n  function next() {\n    if (currentPre >= numPres) {\n      return;\n    }\n    const pre = pres[currentPre];\n\n    if (pre.isAsync) {\n      const args = [\n        decorateNextFn(_next),\n        decorateNextFn(function(error) {\n          if (error) {\n            if (done) {\n              return;\n            }\n            if (error instanceof Kareem.skipWrappedFunction) {\n              shouldSkipWrappedFunction = error;\n            } else {\n              done = true;\n              return callback(error);\n            }\n          }\n          if (--asyncPresLeft === 0 && currentPre >= numPres) {\n            return callback(shouldSkipWrappedFunction);\n          }\n        })\n      ];\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else if (pre.fn.length > 0) {\n      const args = [decorateNextFn(_next)];\n      const _args = arguments.length >= 2 ? arguments : [null].concat($args);\n      for (let i = 1; i < _args.length; ++i) {\n        if (i === _args.length - 1 && typeof _args[i] === 'function') {\n          continue; // skip callbacks to avoid accidentally calling the callback from a hook\n        }\n        args.push(_args[i]);\n      }\n\n      callMiddlewareFunction(pre.fn, context, args, args[0]);\n    } else {\n      let maybePromiseLike = null;\n      try {\n        maybePromiseLike = pre.fn.call(context);\n      } catch (err) {\n        if (err != null) {\n          return callback(err);\n        }\n      }\n\n      if (isPromiseLike(maybePromiseLike)) {\n        maybePromiseLike.then(() => _next(), err => _next(err));\n      } else {\n        if (++currentPre >= numPres) {\n          if (asyncPresLeft > 0) {\n            // Leave parallel hooks to run\n            return;\n          } else {\n            return nextTick(function() {\n              callback(shouldSkipWrappedFunction);\n            });\n          }\n        }\n        next();\n      }\n    }\n  }\n\n  next.apply(null, [null].concat(args));\n\n  function _next(error) {\n    if (error) {\n      if (done) {\n        return;\n      }\n      if (error instanceof Kareem.skipWrappedFunction) {\n        shouldSkipWrappedFunction = error;\n      } else {\n        done = true;\n        return callback(error);\n      }\n    }\n\n    if (++currentPre >= numPres) {\n      if (asyncPresLeft > 0) {\n        // Leave parallel hooks to run\n        return;\n      } else {\n        return callback(shouldSkipWrappedFunction);\n      }\n    }\n\n    next.apply(context, arguments);\n  }\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @returns {void}\n */\nKareem.prototype.execPreSync = function(name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n\n  for (let i = 0; i < numPres; ++i) {\n    pres[i].fn.apply(context, args || []);\n  }\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @param {*} options Optional options or directly the callback\n * @param {Function} [callback] The callback to call when executing all hooks are finished\n * @returns {void}\n */\nKareem.prototype.execPost = function(name, context, args, options, callback) {\n  if (arguments.length < 5) {\n    callback = options;\n    options = null;\n  }\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  let currentPost = 0;\n\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n\n  if (!numPosts) {\n    return nextTick(function() {\n      callback.apply(null, [firstError].concat(args));\n    });\n  }\n\n  function next() {\n    const post = posts[currentPost].fn;\n    let numArgs = 0;\n    const argLength = args.length;\n    const newArgs = [];\n    for (let i = 0; i < argLength; ++i) {\n      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;\n      if (!args[i] || !args[i]._kareemIgnore) {\n        newArgs.push(args[i]);\n      }\n    }\n\n    if (firstError) {\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        const _cb = decorateNextFn(function(error) {\n          if (error) {\n            if (error instanceof Kareem.overwriteResult) {\n              args = error.args;\n              if (++currentPost >= numPosts) {\n                return callback.call(null, firstError);\n              }\n              return next();\n            }\n            firstError = error;\n          }\n          if (++currentPost >= numPosts) {\n            return callback.call(null, firstError);\n          }\n          next();\n        });\n\n        callMiddlewareFunction(post, context,\n          [firstError].concat(newArgs).concat([_cb]), _cb);\n      } else {\n        if (++currentPost >= numPosts) {\n          return callback.call(null, firstError);\n        }\n        next();\n      }\n    } else {\n      const _cb = decorateNextFn(function(error) {\n        if (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            if (++currentPost >= numPosts) {\n              return callback.apply(null, [null].concat(args));\n            }\n            return next();\n          }\n          firstError = error;\n          return next();\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n\n        next();\n      });\n\n      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {\n        // Skip error handlers if no error\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [null].concat(args));\n        }\n        return next();\n      }\n      if (post.length === numArgs + 1) {\n        callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);\n      } else {\n        let error;\n        let maybePromiseLike;\n        try {\n          maybePromiseLike = post.apply(context, newArgs);\n        } catch (err) {\n          error = err;\n          firstError = err;\n        }\n\n        if (isPromiseLike(maybePromiseLike)) {\n          return maybePromiseLike.then(\n            (res) => {\n              _cb(res instanceof Kareem.overwriteResult ? res : null);\n            },\n            err => _cb(err)\n          );\n        }\n\n        if (maybePromiseLike instanceof Kareem.overwriteResult) {\n          args = maybePromiseLike.args;\n        }\n\n        if (++currentPost >= numPosts) {\n          return callback.apply(null, [error].concat(args));\n        }\n\n        next();\n      }\n    }\n  }\n\n  next();\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array|Function} args Apply custom arguments to the hook\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function(name, context, args) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function(name, fn) {\n  const _this = this;\n  return function syncWrapper() {\n    _this.execPreSync(name, this, arguments);\n\n    const toReturn = fn.apply(this, arguments);\n\n    const result = _this.execPostSync(name, this, [toReturn]);\n\n    return result[0];\n  };\n};\n\nfunction _handleWrapError(instance, error, name, context, args, options, callback) {\n  if (options.useErrorHandlers) {\n    return instance.execPost(name, context, args, { error: error }, function(error) {\n      return typeof callback === 'function' && callback(error);\n    });\n  } else {\n    return typeof callback === 'function' && callback(error);\n  }\n}\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} [options]\n * @param {Boolean} [options.checkForPromise]\n * @returns {void}\n */\nKareem.prototype.wrap = function(name, fn, context, args, options) {\n  const lastArg = (args.length > 0 ? args[args.length - 1] : null);\n  const argsWithoutCb = Array.from(args);\n  typeof lastArg === 'function' && argsWithoutCb.pop();\n  const _this = this;\n\n  options = options || {};\n  const checkForPromise = options.checkForPromise;\n\n  this.execPre(name, context, args, function(error) {\n    if (error && !(error instanceof Kareem.skipWrappedFunction)) {\n      const numCallbackParams = options.numCallbackParams || 0;\n      const errorArgs = options.contextParameter ? [context] : [];\n      for (let i = errorArgs.length; i < numCallbackParams; ++i) {\n        errorArgs.push(null);\n      }\n      return _handleWrapError(_this, error, name, context, errorArgs,\n        options, lastArg);\n    }\n\n    const numParameters = fn.length;\n    let ret;\n\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args[0];\n      return _cb(null, ...error.args);\n    } else {\n      try {\n        ret = fn.apply(context, argsWithoutCb.concat(_cb));\n      } catch (err) {\n        return _cb(err);\n      }\n    }\n\n    if (checkForPromise) {\n      if (isPromiseLike(ret)) {\n        // Thenable, use it\n        return ret.then(\n          res => _cb(null, res),\n          err => _cb(err)\n        );\n      }\n\n      // If `fn()` doesn't have a callback argument and doesn't return a\n      // promise, assume it is sync\n      if (numParameters < argsWithoutCb.length + 1) {\n        return _cb(null, ret);\n      }\n    }\n\n    function _cb() {\n      const argsWithoutError = Array.from(arguments);\n      argsWithoutError.shift();\n      if (options.nullResultByDefault && argsWithoutError.length === 0) {\n        argsWithoutError.push(null);\n      }\n      if (arguments[0]) {\n        // Assume error\n        return _handleWrapError(_this, arguments[0], name, context,\n          argsWithoutError, options, lastArg);\n      } else {\n        _this.execPost(name, context, argsWithoutError, function() {\n          if (lastArg === null) {\n            return;\n          }\n          arguments[0]\n            ? lastArg(arguments[0])\n            : lastArg.apply(context, arguments);\n        });\n      }\n    }\n  });\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function(fn) {\n  const clone = this.clone();\n\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n\n    hooks.numAsync = hooks.filter(h => h.isAsync).length;\n\n    clone._pres.set(name, hooks);\n  }\n\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n\n    clone._posts.set(name, hooks);\n  }\n\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function(name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function(name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the\n    // function wrapped in a nextTick()\n    return function() {\n      nextTick(() => fn.apply(this, arguments));\n    };\n  }\n  return function() {\n    const _context = context || this;\n    _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Boolean} [isAsync]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function(name, isAsync, fn, error, unshift) {\n  let options = {};\n  if (typeof isAsync === 'object' && isAsync !== null) {\n    options = isAsync;\n    isAsync = options.isAsync;\n  } else if (typeof arguments[1] !== 'boolean') {\n    fn = isAsync;\n    isAsync = false;\n  }\n\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n\n  if (isAsync) {\n    pres.numAsync = pres.numAsync || 0;\n    ++pres.numAsync;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  } else {\n    pres.push(Object.assign({}, options, { fn: fn, isAsync: isAsync }));\n  }\n\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function(name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    posts.push(Object.assign({}, options, { fn: fn }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function() {\n  const n = new Kareem();\n\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    clone.numAsync = this._pres.get(key).numAsync;\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function(other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n      // Deduplicate based on `fn`\n      filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    combined.numAsync = sourcePres.numAsync || 0;\n    combined.numAsync += deduplicated.filter(p => p.isAsync).length;\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).\n      filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n\n  return ret;\n};\n\nfunction callMiddlewareFunction(fn, context, args, next) {\n  let maybePromiseLike;\n  try {\n    maybePromiseLike = fn.apply(context, args);\n  } catch (error) {\n    return next(error);\n  }\n\n  if (isPromiseLike(maybePromiseLike)) {\n    maybePromiseLike.then(() => next(), err => next(err));\n  }\n}\n\nfunction isPromiseLike(v) {\n  return (typeof v === 'object' && v !== null && typeof v.then === 'function');\n}\n\nfunction decorateNextFn(fn) {\n  let called = false;\n  const _this = this;\n  return function() {\n    // Ensure this function can only be called once\n    if (called) {\n      return;\n    }\n    called = true;\n    // Make sure to clear the stack so try/catch doesn't catch errors\n    // in subsequent middleware\n    return nextTick(() => fn.apply(_this, arguments));\n  };\n}\n\nconst nextTick = typeof process === 'object' && process !== null && process.nextTick || function nextTick(cb) {\n  setTimeout(cb, 0);\n};\n\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\n\nmodule.exports = Kareem;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0va2FyZWVtQDIuNi4zL25vZGVfbW9kdWxlcy9rYXJlZW0vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL25pY2svRGVza3RvcC9CdXNpbmVzcy9QYXlsb2FkQ01TL3BheWxvYWQtc3RvcmFnZS1jbG91ZGluYXJ5L2Rldi9ub2RlX21vZHVsZXMvLnBucG0va2FyZWVtQDIuNi4zL25vZGVfbW9kdWxlcy9rYXJlZW0vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBLYXJlZW0oKSB7XG4gIHRoaXMuX3ByZXMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuX3Bvc3RzID0gbmV3IE1hcCgpO1xufVxuXG5LYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbiA9IGZ1bmN0aW9uIHNraXBXcmFwcGVkRnVuY3Rpb24oKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikpIHtcbiAgICByZXR1cm4gbmV3IEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICB0aGlzLmFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcbn07XG5cbkthcmVlbS5vdmVyd3JpdGVSZXN1bHQgPSBmdW5jdGlvbiBvdmVyd3JpdGVSZXN1bHQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KSkge1xuICAgIHJldHVybiBuZXcgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgdGhpcy5hcmdzID0gWy4uLmFyZ3VtZW50c107XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYWxsIFwicHJlXCIgaG9va3MgZm9yIFwibmFtZVwiXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaG9vayBuYW1lIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gYXJncyBPcHRpb25hbCBhcmd1bWVudHMgb3IgZGlyZWN0bHkgdGhlIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gZXhlY3V0aW5nIGFsbCBob29rcyBhcmUgZmluaXNoZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmV4ZWNQcmUgPSBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBhcmdzLCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGNhbGxiYWNrID0gYXJncztcbiAgICBhcmdzID0gW107XG4gIH1cbiAgY29uc3QgcHJlcyA9IHRoaXMuX3ByZXMuZ2V0KG5hbWUpIHx8IFtdO1xuICBjb25zdCBudW1QcmVzID0gcHJlcy5sZW5ndGg7XG4gIGNvbnN0IG51bUFzeW5jUHJlcyA9IHByZXMubnVtQXN5bmMgfHwgMDtcbiAgbGV0IGN1cnJlbnRQcmUgPSAwO1xuICBsZXQgYXN5bmNQcmVzTGVmdCA9IG51bUFzeW5jUHJlcztcbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgY29uc3QgJGFyZ3MgPSBhcmdzO1xuICBsZXQgc2hvdWxkU2tpcFdyYXBwZWRGdW5jdGlvbiA9IG51bGw7XG5cbiAgaWYgKCFudW1QcmVzKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChjdXJyZW50UHJlID49IG51bVByZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJlID0gcHJlc1tjdXJyZW50UHJlXTtcblxuICAgIGlmIChwcmUuaXNBc3luYykge1xuICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgZGVjb3JhdGVOZXh0Rm4oX25leHQpLFxuICAgICAgICBkZWNvcmF0ZU5leHRGbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgc2hvdWxkU2tpcFdyYXBwZWRGdW5jdGlvbiA9IGVycm9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgtLWFzeW5jUHJlc0xlZnQgPT09IDAgJiYgY3VycmVudFByZSA+PSBudW1QcmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soc2hvdWxkU2tpcFdyYXBwZWRGdW5jdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgXTtcblxuICAgICAgY2FsbE1pZGRsZXdhcmVGdW5jdGlvbihwcmUuZm4sIGNvbnRleHQsIGFyZ3MsIGFyZ3NbMF0pO1xuICAgIH0gZWxzZSBpZiAocHJlLmZuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBbZGVjb3JhdGVOZXh0Rm4oX25leHQpXTtcbiAgICAgIGNvbnN0IF9hcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzIDogW251bGxdLmNvbmNhdCgkYXJncyk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IF9hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBfYXJncy5sZW5ndGggLSAxICYmIHR5cGVvZiBfYXJnc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIGNhbGxiYWNrcyB0byBhdm9pZCBhY2NpZGVudGFsbHkgY2FsbGluZyB0aGUgY2FsbGJhY2sgZnJvbSBhIGhvb2tcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goX2FyZ3NbaV0pO1xuICAgICAgfVxuXG4gICAgICBjYWxsTWlkZGxld2FyZUZ1bmN0aW9uKHByZS5mbiwgY29udGV4dCwgYXJncywgYXJnc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtYXliZVByb21pc2VMaWtlID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1heWJlUHJvbWlzZUxpa2UgPSBwcmUuZm4uY2FsbChjb250ZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNQcm9taXNlTGlrZShtYXliZVByb21pc2VMaWtlKSkge1xuICAgICAgICBtYXliZVByb21pc2VMaWtlLnRoZW4oKCkgPT4gX25leHQoKSwgZXJyID0+IF9uZXh0KGVycikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCsrY3VycmVudFByZSA+PSBudW1QcmVzKSB7XG4gICAgICAgICAgaWYgKGFzeW5jUHJlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBMZWF2ZSBwYXJhbGxlbCBob29rcyB0byBydW5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV4dC5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcblxuICBmdW5jdGlvbiBfbmV4dChlcnJvcikge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgICAgc2hvdWxkU2tpcFdyYXBwZWRGdW5jdGlvbiA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCsrY3VycmVudFByZSA+PSBudW1QcmVzKSB7XG4gICAgICBpZiAoYXN5bmNQcmVzTGVmdCA+IDApIHtcbiAgICAgICAgLy8gTGVhdmUgcGFyYWxsZWwgaG9va3MgdG8gcnVuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhzaG91bGRTa2lwV3JhcHBlZEZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0LmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhbGwgXCJwcmVcIiBob29rcyBmb3IgXCJuYW1lXCIgc3luY2hyb25vdXNseVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGhvb2sgbmFtZSB0byBleGVjdXRlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT3ZlcndyaXRlIHRoZSBcInRoaXNcIiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSBBcHBseSBjdXN0b20gYXJndW1lbnRzIHRvIHRoZSBob29rXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5leGVjUHJlU3luYyA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGFyZ3MpIHtcbiAgY29uc3QgcHJlcyA9IHRoaXMuX3ByZXMuZ2V0KG5hbWUpIHx8IFtdO1xuICBjb25zdCBudW1QcmVzID0gcHJlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QcmVzOyArK2kpIHtcbiAgICBwcmVzW2ldLmZuLmFwcGx5KGNvbnRleHQsIGFyZ3MgfHwgW10pO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYWxsIFwicG9zdFwiIGhvb2tzIGZvciBcIm5hbWVcIlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGhvb2sgbmFtZSB0byBleGVjdXRlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT3ZlcndyaXRlIHRoZSBcInRoaXNcIiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGFyZ3MgQXBwbHkgY3VzdG9tIGFyZ3VtZW50cyB0byB0aGUgaG9va1xuICogQHBhcmFtIHsqfSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgb3IgZGlyZWN0bHkgdGhlIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gZXhlY3V0aW5nIGFsbCBob29rcyBhcmUgZmluaXNoZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmV4ZWNQb3N0ID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYXJncywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA1KSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGNvbnN0IHBvc3RzID0gdGhpcy5fcG9zdHMuZ2V0KG5hbWUpIHx8IFtdO1xuICBjb25zdCBudW1Qb3N0cyA9IHBvc3RzLmxlbmd0aDtcbiAgbGV0IGN1cnJlbnRQb3N0ID0gMDtcblxuICBsZXQgZmlyc3RFcnJvciA9IG51bGw7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXJyb3IpIHtcbiAgICBmaXJzdEVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgfVxuXG4gIGlmICghbnVtUG9zdHMpIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbZmlyc3RFcnJvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgY29uc3QgcG9zdCA9IHBvc3RzW2N1cnJlbnRQb3N0XS5mbjtcbiAgICBsZXQgbnVtQXJncyA9IDA7XG4gICAgY29uc3QgYXJnTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgY29uc3QgbmV3QXJncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnTGVuZ3RoOyArK2kpIHtcbiAgICAgIG51bUFyZ3MgKz0gYXJnc1tpXSAmJiBhcmdzW2ldLl9rYXJlZW1JZ25vcmUgPyAwIDogMTtcbiAgICAgIGlmICghYXJnc1tpXSB8fCAhYXJnc1tpXS5fa2FyZWVtSWdub3JlKSB7XG4gICAgICAgIG5ld0FyZ3MucHVzaChhcmdzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlyc3RFcnJvcikge1xuICAgICAgaWYgKGlzRXJyb3JIYW5kbGluZ01pZGRsZXdhcmUocG9zdHNbY3VycmVudFBvc3RdLCBudW1BcmdzKSkge1xuICAgICAgICBjb25zdCBfY2IgPSBkZWNvcmF0ZU5leHRGbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgS2FyZWVtLm92ZXJ3cml0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICBhcmdzID0gZXJyb3IuYXJncztcbiAgICAgICAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChudWxsLCBmaXJzdEVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RFcnJvciA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytjdXJyZW50UG9zdCA+PSBudW1Qb3N0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwobnVsbCwgZmlyc3RFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FsbE1pZGRsZXdhcmVGdW5jdGlvbihwb3N0LCBjb250ZXh0LFxuICAgICAgICAgIFtmaXJzdEVycm9yXS5jb25jYXQobmV3QXJncykuY29uY2F0KFtfY2JdKSwgX2NiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwobnVsbCwgZmlyc3RFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBfY2IgPSBkZWNvcmF0ZU5leHRGbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBhcmdzID0gZXJyb3IuYXJncztcbiAgICAgICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrY3VycmVudFBvc3QgPj0gbnVtUG9zdHMpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzRXJyb3JIYW5kbGluZ01pZGRsZXdhcmUocG9zdHNbY3VycmVudFBvc3RdLCBudW1BcmdzKSkge1xuICAgICAgICAvLyBTa2lwIGVycm9yIGhhbmRsZXJzIGlmIG5vIGVycm9yXG4gICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAocG9zdC5sZW5ndGggPT09IG51bUFyZ3MgKyAxKSB7XG4gICAgICAgIGNhbGxNaWRkbGV3YXJlRnVuY3Rpb24ocG9zdCwgY29udGV4dCwgbmV3QXJncy5jb25jYXQoW19jYl0pLCBfY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBsZXQgbWF5YmVQcm9taXNlTGlrZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYXliZVByb21pc2VMaWtlID0gcG9zdC5hcHBseShjb250ZXh0LCBuZXdBcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1Byb21pc2VMaWtlKG1heWJlUHJvbWlzZUxpa2UpKSB7XG4gICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZUxpa2UudGhlbihcbiAgICAgICAgICAgIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgX2NiKHJlcyBpbnN0YW5jZW9mIEthcmVlbS5vdmVyd3JpdGVSZXN1bHQgPyByZXMgOiBudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnIgPT4gX2NiKGVycilcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZUxpa2UgaW5zdGFuY2VvZiBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KSB7XG4gICAgICAgICAgYXJncyA9IG1heWJlUHJvbWlzZUxpa2UuYXJncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK2N1cnJlbnRQb3N0ID49IG51bVBvc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtlcnJvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYWxsIFwicG9zdFwiIGhvb2tzIGZvciBcIm5hbWVcIiBzeW5jaHJvbm91c2x5XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaG9vayBuYW1lIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPdmVyd3JpdGUgdGhlIFwidGhpc1wiIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gYXJncyBBcHBseSBjdXN0b20gYXJndW1lbnRzIHRvIHRoZSBob29rXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB1c2VkIGFyZ3VtZW50c1xuICovXG5LYXJlZW0ucHJvdG90eXBlLmV4ZWNQb3N0U3luYyA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGFyZ3MpIHtcbiAgY29uc3QgcG9zdHMgPSB0aGlzLl9wb3N0cy5nZXQobmFtZSkgfHwgW107XG4gIGNvbnN0IG51bVBvc3RzID0gcG9zdHMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9zdHM7ICsraSkge1xuICAgIGNvbnN0IHJlcyA9IHBvc3RzW2ldLmZuLmFwcGx5KGNvbnRleHQsIGFyZ3MgfHwgW10pO1xuICAgIGlmIChyZXMgaW5zdGFuY2VvZiBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0KSB7XG4gICAgICBhcmdzID0gcmVzLmFyZ3M7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFyZ3M7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHN5bmNocm9ub3VzIHdyYXBwZXIgZm9yIFwiZm5cIlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gKi9cbkthcmVlbS5wcm90b3R5cGUuY3JlYXRlV3JhcHBlclN5bmMgPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiBzeW5jV3JhcHBlcigpIHtcbiAgICBfdGhpcy5leGVjUHJlU3luYyhuYW1lLCB0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgY29uc3QgdG9SZXR1cm4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gX3RoaXMuZXhlY1Bvc3RTeW5jKG5hbWUsIHRoaXMsIFt0b1JldHVybl0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVXcmFwRXJyb3IoaW5zdGFuY2UsIGVycm9yLCBuYW1lLCBjb250ZXh0LCBhcmdzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAob3B0aW9ucy51c2VFcnJvckhhbmRsZXJzKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmV4ZWNQb3N0KG5hbWUsIGNvbnRleHQsIGFyZ3MsIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nICYmIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nICYmIGNhbGxiYWNrKGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHByZSBob29rcywgZm9sbG93ZWQgYnkgdGhlIHdyYXBwZWQgZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IHBvc3QgaG9va3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9va1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGZvciB0aGUgaG9va1xuICogQHBhcmFtIHsqfSBjb250ZXh0IE92ZXJ3cml0ZSB0aGUgXCJ0aGlzXCIgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFwcGx5IGN1c3RvbSBhcmd1bWVudHMgdG8gdGhlIGhvb2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2hlY2tGb3JQcm9taXNlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkthcmVlbS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKG5hbWUsIGZuLCBjb250ZXh0LCBhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxhc3RBcmcgPSAoYXJncy5sZW5ndGggPiAwID8gYXJnc1thcmdzLmxlbmd0aCAtIDFdIDogbnVsbCk7XG4gIGNvbnN0IGFyZ3NXaXRob3V0Q2IgPSBBcnJheS5mcm9tKGFyZ3MpO1xuICB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmdzV2l0aG91dENiLnBvcCgpO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNoZWNrRm9yUHJvbWlzZSA9IG9wdGlvbnMuY2hlY2tGb3JQcm9taXNlO1xuXG4gIHRoaXMuZXhlY1ByZShuYW1lLCBjb250ZXh0LCBhcmdzLCBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pKSB7XG4gICAgICBjb25zdCBudW1DYWxsYmFja1BhcmFtcyA9IG9wdGlvbnMubnVtQ2FsbGJhY2tQYXJhbXMgfHwgMDtcbiAgICAgIGNvbnN0IGVycm9yQXJncyA9IG9wdGlvbnMuY29udGV4dFBhcmFtZXRlciA/IFtjb250ZXh0XSA6IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IGVycm9yQXJncy5sZW5ndGg7IGkgPCBudW1DYWxsYmFja1BhcmFtczsgKytpKSB7XG4gICAgICAgIGVycm9yQXJncy5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9oYW5kbGVXcmFwRXJyb3IoX3RoaXMsIGVycm9yLCBuYW1lLCBjb250ZXh0LCBlcnJvckFyZ3MsXG4gICAgICAgIG9wdGlvbnMsIGxhc3RBcmcpO1xuICAgIH1cblxuICAgIGNvbnN0IG51bVBhcmFtZXRlcnMgPSBmbi5sZW5ndGg7XG4gICAgbGV0IHJldDtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICByZXQgPSBlcnJvci5hcmdzWzBdO1xuICAgICAgcmV0dXJuIF9jYihudWxsLCAuLi5lcnJvci5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJnc1dpdGhvdXRDYi5jb25jYXQoX2NiKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIF9jYihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGVja0ZvclByb21pc2UpIHtcbiAgICAgIGlmIChpc1Byb21pc2VMaWtlKHJldCkpIHtcbiAgICAgICAgLy8gVGhlbmFibGUsIHVzZSBpdFxuICAgICAgICByZXR1cm4gcmV0LnRoZW4oXG4gICAgICAgICAgcmVzID0+IF9jYihudWxsLCByZXMpLFxuICAgICAgICAgIGVyciA9PiBfY2IoZXJyKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBgZm4oKWAgZG9lc24ndCBoYXZlIGEgY2FsbGJhY2sgYXJndW1lbnQgYW5kIGRvZXNuJ3QgcmV0dXJuIGFcbiAgICAgIC8vIHByb21pc2UsIGFzc3VtZSBpdCBpcyBzeW5jXG4gICAgICBpZiAobnVtUGFyYW1ldGVycyA8IGFyZ3NXaXRob3V0Q2IubGVuZ3RoICsgMSkge1xuICAgICAgICByZXR1cm4gX2NiKG51bGwsIHJldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NiKCkge1xuICAgICAgY29uc3QgYXJnc1dpdGhvdXRFcnJvciA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICAgIGFyZ3NXaXRob3V0RXJyb3Iuc2hpZnQoKTtcbiAgICAgIGlmIChvcHRpb25zLm51bGxSZXN1bHRCeURlZmF1bHQgJiYgYXJnc1dpdGhvdXRFcnJvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYXJnc1dpdGhvdXRFcnJvci5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50c1swXSkge1xuICAgICAgICAvLyBBc3N1bWUgZXJyb3JcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVXcmFwRXJyb3IoX3RoaXMsIGFyZ3VtZW50c1swXSwgbmFtZSwgY29udGV4dCxcbiAgICAgICAgICBhcmdzV2l0aG91dEVycm9yLCBvcHRpb25zLCBsYXN0QXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmV4ZWNQb3N0KG5hbWUsIGNvbnRleHQsIGFyZ3NXaXRob3V0RXJyb3IsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChsYXN0QXJnID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3VtZW50c1swXVxuICAgICAgICAgICAgPyBsYXN0QXJnKGFyZ3VtZW50c1swXSlcbiAgICAgICAgICAgIDogbGFzdEFyZy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgY3VycmVudCBpbnN0YW5jZSBmb3Igc29tZXRoaW5nIHNwZWNpZmljIGFuZCByZXR1cm4gdGhlIGZpbHRlcmVkIGNsb25lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZmlsdGVyIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7S2FyZWVtfSBUaGUgY2xvbmVkIGFuZCBmaWx0ZXJlZCBpbnN0YW5jZVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnN0IGNsb25lID0gdGhpcy5jbG9uZSgpO1xuXG4gIGNvbnN0IHByZXMgPSBBcnJheS5mcm9tKGNsb25lLl9wcmVzLmtleXMoKSk7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBwcmVzKSB7XG4gICAgY29uc3QgaG9va3MgPSB0aGlzLl9wcmVzLmdldChuYW1lKS5cbiAgICAgIG1hcChoID0+IE9iamVjdC5hc3NpZ24oe30sIGgsIHsgbmFtZTogbmFtZSB9KSkuXG4gICAgICBmaWx0ZXIoZm4pO1xuXG4gICAgaWYgKGhvb2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2xvbmUuX3ByZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaG9va3MubnVtQXN5bmMgPSBob29rcy5maWx0ZXIoaCA9PiBoLmlzQXN5bmMpLmxlbmd0aDtcblxuICAgIGNsb25lLl9wcmVzLnNldChuYW1lLCBob29rcyk7XG4gIH1cblxuICBjb25zdCBwb3N0cyA9IEFycmF5LmZyb20oY2xvbmUuX3Bvc3RzLmtleXMoKSk7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBwb3N0cykge1xuICAgIGNvbnN0IGhvb2tzID0gdGhpcy5fcG9zdHMuZ2V0KG5hbWUpLlxuICAgICAgbWFwKGggPT4gT2JqZWN0LmFzc2lnbih7fSwgaCwgeyBuYW1lOiBuYW1lIH0pKS5cbiAgICAgIGZpbHRlcihmbik7XG5cbiAgICBpZiAoaG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBjbG9uZS5fcG9zdHMuZGVsZXRlKG5hbWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY2xvbmUuX3Bvc3RzLnNldChuYW1lLCBob29rcyk7XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59O1xuXG4vKipcbiAqIENoZWNrIGZvciBhIFwibmFtZVwiIHRvIGV4aXN0IGVpdGhlciBpbiBwcmUgb3IgcG9zdCBob29rc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBcInRydWVcIiBpZiBmb3VuZCwgXCJmYWxzZVwiIG90aGVyd2lzZVxuICovXG5LYXJlZW0ucHJvdG90eXBlLmhhc0hvb2tzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5fcHJlcy5oYXMobmFtZSkgfHwgdGhpcy5fcG9zdHMuaGFzKG5hbWUpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBXcmFwcGVyIGZvciBcImZuXCIgb24gXCJuYW1lXCIgYW5kIHJldHVybiB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT3ZlcndyaXRlIHRoZSBcInRoaXNcIiBmb3IgdGhlIGhvb2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5jcmVhdGVXcmFwcGVyID0gZnVuY3Rpb24obmFtZSwgZm4sIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAoIXRoaXMuaGFzSG9va3MobmFtZSkpIHtcbiAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZXJlJ3Mgbm8gaG9va3MgZm9yIHRoaXMgZnVuY3Rpb24sIGp1c3QgcmV0dXJuIHRoZVxuICAgIC8vIGZ1bmN0aW9uIHdyYXBwZWQgaW4gYSBuZXh0VGljaygpXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFRpY2soKCkgPT4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgX2NvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgX3RoaXMud3JhcChuYW1lLCBmbiwgX2NvbnRleHQsIEFycmF5LmZyb20oYXJndW1lbnRzKSwgb3B0aW9ucyk7XG4gIH07XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IGhvb2sgZm9yIFwicHJlXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0FzeW5jXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGZvciBcIm5hbWVcIlxuICogQHBhcmFtIHtuZXZlcn0gZXJyb3IgVW51c2VkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1bnNoaWZ0XSBXaGV0ZXIgdG8gXCJwdXNoXCIgb3IgdG8gXCJ1bnNoaWZ0XCIgdGhlIG5ldyBob29rXG4gKiBAcmV0dXJucyB7S2FyZWVtfVxuICovXG5LYXJlZW0ucHJvdG90eXBlLnByZSA9IGZ1bmN0aW9uKG5hbWUsIGlzQXN5bmMsIGZuLCBlcnJvciwgdW5zaGlmdCkge1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBpZiAodHlwZW9mIGlzQXN5bmMgPT09ICdvYmplY3QnICYmIGlzQXN5bmMgIT09IG51bGwpIHtcbiAgICBvcHRpb25zID0gaXNBc3luYztcbiAgICBpc0FzeW5jID0gb3B0aW9ucy5pc0FzeW5jO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICdib29sZWFuJykge1xuICAgIGZuID0gaXNBc3luYztcbiAgICBpc0FzeW5jID0gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcmVzID0gdGhpcy5fcHJlcy5nZXQobmFtZSkgfHwgW107XG4gIHRoaXMuX3ByZXMuc2V0KG5hbWUsIHByZXMpO1xuXG4gIGlmIChpc0FzeW5jKSB7XG4gICAgcHJlcy5udW1Bc3luYyA9IHByZXMubnVtQXN5bmMgfHwgMDtcbiAgICArK3ByZXMubnVtQXN5bmM7XG4gIH1cblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmUoKSByZXF1aXJlcyBhIGZ1bmN0aW9uLCBnb3QgXCInICsgdHlwZW9mIGZuICsgJ1wiJyk7XG4gIH1cblxuICBpZiAodW5zaGlmdCkge1xuICAgIHByZXMudW5zaGlmdChPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGZuOiBmbiwgaXNBc3luYzogaXNBc3luYyB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcHJlcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgZm46IGZuLCBpc0FzeW5jOiBpc0FzeW5jIH0pKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBob29rIGZvciBcInBvc3RcIlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byByZWdpc3RlciBmb3IgXCJuYW1lXCJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Vuc2hpZnRdIFdoZXRlciB0byBcInB1c2hcIiBvciB0byBcInVuc2hpZnRcIiB0aGUgbmV3IGhvb2tcbiAqIEByZXR1cm5zIHtLYXJlZW19XG4gKi9cbkthcmVlbS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMsIGZuLCB1bnNoaWZ0KSB7XG4gIGNvbnN0IHBvc3RzID0gdGhpcy5fcG9zdHMuZ2V0KG5hbWUpIHx8IFtdO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVuc2hpZnQgPSAhIWZuO1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwb3N0KCkgcmVxdWlyZXMgYSBmdW5jdGlvbiwgZ290IFwiJyArIHR5cGVvZiBmbiArICdcIicpO1xuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHtcbiAgICBwb3N0cy51bnNoaWZ0KE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgZm46IGZuIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBwb3N0cy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgZm46IGZuIH0pKTtcbiAgfVxuICB0aGlzLl9wb3N0cy5zZXQobmFtZSwgcG9zdHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtLYXJlZW19IFRoZSBjbG9uZWQgaW5zdGFuY2VcbiAqL1xuS2FyZWVtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBuID0gbmV3IEthcmVlbSgpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuX3ByZXMua2V5cygpKSB7XG4gICAgY29uc3QgY2xvbmUgPSB0aGlzLl9wcmVzLmdldChrZXkpLnNsaWNlKCk7XG4gICAgY2xvbmUubnVtQXN5bmMgPSB0aGlzLl9wcmVzLmdldChrZXkpLm51bUFzeW5jO1xuICAgIG4uX3ByZXMuc2V0KGtleSwgY2xvbmUpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuX3Bvc3RzLmtleXMoKSkge1xuICAgIG4uX3Bvc3RzLnNldChrZXksIHRoaXMuX3Bvc3RzLmdldChrZXkpLnNsaWNlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG47XG59O1xuXG4vKipcbiAqIE1lcmdlIFwib3RoZXJcIiBpbnRvIHNlbGYgb3IgXCJjbG9uZVwiXG4gKiBAcGFyYW0ge0thcmVlbX0gb3RoZXIgVGhlIGluc3RhbmNlIHRvIG1lcmdlIHdpdGhcbiAqIEBwYXJhbSB7S2FyZWVtfSBbY2xvbmVdIFRoZSBpbnN0YW5jZSB0byBtZXJnZSBvbnRvIChpZiBub3QgZGVmaW5lZCwgdXNpbmcgXCJ0aGlzXCIpXG4gKiBAcmV0dXJucyB7S2FyZWVtfSBUaGUgbWVyZ2VkIGluc3RhbmNlXG4gKi9cbkthcmVlbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlciwgY2xvbmUpIHtcbiAgY2xvbmUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdHJ1ZSA6IGNsb25lO1xuICBjb25zdCByZXQgPSBjbG9uZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXM7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Ygb3RoZXIuX3ByZXMua2V5cygpKSB7XG4gICAgY29uc3Qgc291cmNlUHJlcyA9IHJldC5fcHJlcy5nZXQoa2V5KSB8fCBbXTtcbiAgICBjb25zdCBkZWR1cGxpY2F0ZWQgPSBvdGhlci5fcHJlcy5nZXQoa2V5KS5cbiAgICAgIC8vIERlZHVwbGljYXRlIGJhc2VkIG9uIGBmbmBcbiAgICAgIGZpbHRlcihwID0+IHNvdXJjZVByZXMubWFwKF9wID0+IF9wLmZuKS5pbmRleE9mKHAuZm4pID09PSAtMSk7XG4gICAgY29uc3QgY29tYmluZWQgPSBzb3VyY2VQcmVzLmNvbmNhdChkZWR1cGxpY2F0ZWQpO1xuICAgIGNvbWJpbmVkLm51bUFzeW5jID0gc291cmNlUHJlcy5udW1Bc3luYyB8fCAwO1xuICAgIGNvbWJpbmVkLm51bUFzeW5jICs9IGRlZHVwbGljYXRlZC5maWx0ZXIocCA9PiBwLmlzQXN5bmMpLmxlbmd0aDtcbiAgICByZXQuX3ByZXMuc2V0KGtleSwgY29tYmluZWQpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIG90aGVyLl9wb3N0cy5rZXlzKCkpIHtcbiAgICBjb25zdCBzb3VyY2VQb3N0cyA9IHJldC5fcG9zdHMuZ2V0KGtleSkgfHwgW107XG4gICAgY29uc3QgZGVkdXBsaWNhdGVkID0gb3RoZXIuX3Bvc3RzLmdldChrZXkpLlxuICAgICAgZmlsdGVyKHAgPT4gc291cmNlUG9zdHMuaW5kZXhPZihwKSA9PT0gLTEpO1xuICAgIHJldC5fcG9zdHMuc2V0KGtleSwgc291cmNlUG9zdHMuY29uY2F0KGRlZHVwbGljYXRlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNhbGxNaWRkbGV3YXJlRnVuY3Rpb24oZm4sIGNvbnRleHQsIGFyZ3MsIG5leHQpIHtcbiAgbGV0IG1heWJlUHJvbWlzZUxpa2U7XG4gIHRyeSB7XG4gICAgbWF5YmVQcm9taXNlTGlrZSA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgfVxuXG4gIGlmIChpc1Byb21pc2VMaWtlKG1heWJlUHJvbWlzZUxpa2UpKSB7XG4gICAgbWF5YmVQcm9taXNlTGlrZS50aGVuKCgpID0+IG5leHQoKSwgZXJyID0+IG5leHQoZXJyKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZSh2KSB7XG4gIHJldHVybiAodHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwgJiYgdHlwZW9mIHYudGhlbiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlTmV4dEZuKGZuKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gRW5zdXJlIHRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgLy8gTWFrZSBzdXJlIHRvIGNsZWFyIHRoZSBzdGFjayBzbyB0cnkvY2F0Y2ggZG9lc24ndCBjYXRjaCBlcnJvcnNcbiAgICAvLyBpbiBzdWJzZXF1ZW50IG1pZGRsZXdhcmVcbiAgICByZXR1cm4gbmV4dFRpY2soKCkgPT4gZm4uYXBwbHkoX3RoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5jb25zdCBuZXh0VGljayA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzICE9PSBudWxsICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgZnVuY3Rpb24gbmV4dFRpY2soY2IpIHtcbiAgc2V0VGltZW91dChjYiwgMCk7XG59O1xuXG5mdW5jdGlvbiBpc0Vycm9ySGFuZGxpbmdNaWRkbGV3YXJlKHBvc3QsIG51bUFyZ3MpIHtcbiAgaWYgKHBvc3QuZXJyb3JIYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHBvc3QuZm4ubGVuZ3RoID09PSBudW1BcmdzICsgMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBLYXJlZW07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/kareem@2.6.3/node_modules/kareem/index.js\n");

/***/ })

};
;